#лямба-функции
# def pol(x,a,b):
#     return a*x**2+b*x+c
#instead write
# a=lambda x: x+x**0.5
# print(a(5))
#lamba func is faster

#map применяет первый аргумент к каждому элементу из второго аргумента
#filter(f,values) - фильтрует значения с помощью функции f
# reduce - берёт парами числа. функция агрегации. по-элементно применяет первый аргумент ко второму.
# from functools import reduce as r
# a=[1,2,3,4,5]
# s=r(lambda x,y: x+y, a) #сумма всех элем-ов списка
# print(s)

#РЕКУРСИЯ - рекурсиваня функция, которая вызывает саму себя
# важен критерий остановки
# sys.setrecursionlimit(1000000) для каждого вызова хранится результат
# если можно без рекурсии, то лучше без неё
# число фиббоначи оптимальнее находить через цикл

# переменная может быть функцией
# фабрика функций
# декоратор - обёртка над функцией, которая даёт ей новые свойства
# nonlocal - на один уровень выше локального
# raise Exception("some text")

#генераторы и итерататоры
# iter(c)
# enumerate(a) - вернёт итератор с парами чисел (номер элемента, сам элемент)
# любой генератор можно сделать с помощью итератора
# yield - это ключевое слово в Python, которое используется для возврата из функции с сохранением состояния ее локальных переменных, и при повторном вызове такой функции выполнение продолжается с оператора yield, на котором ее работа была прервана.
# Любая функция, содержащая ключевое слово yield, называется генератором. Можно сказать, yield — это то, что делает ее генератором.
# никогда не знаем, когда генератор закончится
# можно генератор передать внутрь функции.  создавать из генератора новый генер.
# генераторы и итераторы - для экономии памяти



# SEMINAR
# функция выыодит первые строки треугольника паскаля
# def pascal(n):
#     '''n first lines of Pascal triangle'''
#     t=[]
#     sp=[]
#     for i in range(n):
#         row1=[1]*(i+1)
#         for j in range(1,i):
#             row1[j]=t[i-1][j-1]+t[i-1][j]
#         t.append(row1)
#         l=str(row1)
#         sp.append(l)
#     return sp
#
# print(pascal(10))
# sp=pascal(10)
# for i in sp:
#     print(" "*((len(sp[-1])-len(i))//2, i)

def blin(func):
    def wrapper(s):
        func(s)
    return wrapper

@blin
def func(s):
    print(s)
s='hello world'
func(s,3)
















